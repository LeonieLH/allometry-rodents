---
title: "04-measure-evolutionary-allometry"
author: "Ariel Marcy"
date: "2019-01-11"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = '../aus-rodent-skulls')
```

# Phylogenetic analyses
Evolutionary studies must take into account the phylogenetic tree because related species do not behave the same as independent samples. 

Many of these steps are based on Dr Meriam Zelditch et al.'s A Practical Companion (2012). 
> Zelditch ML Swiderski D Sheets HD. 2012. A practical companion to geometric morphometrics for biologists: running analyses in freely-available software. Available at: http://booksite.elsevier.com/9780123869036.

### Load packages, functions, and data
```{r message = FALSE}
library(dispRity)
library(stringr)
library(data.table)
library(geomorph)
library(ape)  # needed to work with phylogenies from here on
library(geiger)
library(nlme)
library(caper)
library(car)
source("../Functions/utilities.R")  # loads custom functions
load(file = "../Data/Processed/02-main-data.rda")
```

### Set up shape array for phylogentic analyses
First, attach long form names for genus and species to the metadata.
```{r}
# Get names from trait information gathered from the book, Native Mice and Rats by Dr.s Bill Breed and Fred Ford (2007). 
traits <- read.csv("../Data/Processed/in_ex_traits.csv", header = TRUE)
traits$Taxa <- paste(str_sub(traits$Genus, 1, 1), str_sub(traits$Species, 1, 3), sep = "_")  # make matching Taxa column
info.traits <- merge(info, traits, by = "Taxa", sort = F)
info.traits <- info.traits[order(info.traits$Order), ]  # preserve shape specimen order

# Rename Genus & Species columns they have their old, short column name, long form Genus and Species columns will keep Genus.y and Species.y
names(info.traits)[names(info.traits) == 'Genus.x'] <- 'Genus'
names(info.traits)[names(info.traits) == 'Species.x'] <- 'Species'

# Remove unnecessary columns
info.phylo <- info.traits[, -c(5:7)]
```

Second, rename dimnames for the shape dataset so that it's only "Genus_species". This is so we can re-order the shape data to match the tree later on. (We can still reference the CatNum in the metadata.)
```{r}
shape.phylo <- shape  # initiate shape optimized for phylogenetics
dimnames(shape.phylo)[[3]] <- as.list(paste(info.phylo$Genus.y, info.phylo$Species.y, sep = "_"))
```

## Calculate mean shape and centroid size for each species
This step has to be done before working with the tree. To calculate the mean shape for each species, we'll use a function from `geomorph` called `m.shape()`. 

To get the means, we'll subset for each unique species. The mean shape function, `mshape()` gives a 2D array as an output. Therefore, the `for` loop below stores mean shapes in a 2D array format recognized by `geomorph`: (n x [p x k]), where n is number of specimens, p is number of landmark points, and k is number of dimensions. Then we convert to a 3D array with format (p x k x n) since a 3D array is required by most `geomorph` functions. 
```{r}
info.phylo$FullName <- paste(info.phylo$Genus.y, info.phylo$Species.y, sep = "_")  # give names to metadata in the same format as the tree "Genus_species"
full.names <- unique(info.phylo$FullName)

# For loop to subset shape data by species and calculate mean shape
mean.shapes.2D <- NULL  # initiate blank data frame
for (i in 1:length(full.names)) {  
        is.taxa <- which(info.phylo$FullName == full.names[i])
        shape.for.mean.2D <- shape.phylo[, , is.taxa]
        mean.shapes.2D <- rbind(mean.shapes.2D, mshape(shape.for.mean.2D))  # mshape() finds mean specimen; rbind() is critical, output cols must = 3 for 3D
}
mean.shapes <- arrayspecs(mean.shapes.2D, 325, 3)  # convert to 3D array

# Make names match the tree, make metadata match mean shape data (alphabetical)
dimnames(mean.shapes)[[3]] <- full.names  # shape names match tree names
info.means <- info.phylo[!duplicated(info.phylo$Taxa), ]  # make metadata; remove columns that don't make sense: CatNum and Order
info.means <- info.means[order(info.means$FullName), ]  # order same as shape's

# Make an Effective Genus column to better categorize Mas phylogenetically
info.means$EGenus <- info.means$Genus
info.means$EGenus[which(info.means$Genus == "Mas")] <- "Pse"
```

### Calculate mean centroid size
We need to update the centoid size column for info.means to contain the *mean* centroid size by taxa. Centroid size is stored in the info.phylo metadata table.
```{r}
# Calculate mean centroid size and store in info.means
cs.means <- aggregate(info.phylo[, 6], list(Taxa = info.phylo$FullName), mean)
info.means$Csize <- cs.means[, 2]  # store in vector; aggregate alphabetized it
names(info.means)[names(info.means) == 'Csize'] <- 'MeanCsize'  # rename column

# Sort shape by alphabetical order, too
mean.shapes <- mean.shapes[, , sort(dimnames(mean.shapes)[[3]])]
```

### Plot PCA of skull shape means by species
Before adding the tree, we can plot the PCA of mean shapes, which will contain more species than the set subsetted by species found in the tree.
```{r}
# Set colors for genera and different points for species within each genus
col.means <- PlotByGroup(info.means, "EGenus", col.gen)  # standard colors
pch.means <- PointOutDiffSpp(info.means)  # points by unique species in a genus

# Plot PCA of mean shapes
pca.means <- plotTangentSpace(mean.shapes)
PlotPCA(pca.means, 1, 2, col.means, pch.means, flip.axis1 = TRUE)
legend(0.094, 0.002, legend = info.means$Taxa, col = col.means, border = NULL, pch = pch.means, pt.bg = col.means, cex = 0.4, ncol = 3)
```

### Correlation of PC1 and PC2 wtih Centroid size
Here we find Pearson's r for correlation with PC1 and PC2.
```{r}
cor.1 <- cor.test(info.means$MeanCsize, -pca.means$pc.scores[, 1], method = "pearson")  # flipped axis to match graph above
cor.1 <- round(unname(cor.1$estimate), digits = 3)  # PC1
cor.2 <- cor.test(info.means$MeanCsize, pca.means$pc.scores[, 2], method = "pearson")  
cor.2  # PC2

# Call out specialized herbivores with squares
pch.evo.allo <- rep(16, length(col.means))
pch.evo.allo[which(info.means$Taxa == "P_ora")] <- 15 
pch.evo.allo[which(info.means$Taxa == "M_fus")] <- 15

# Visualize Log(CS) vs PC1
plot(x = log(info.means$MeanCsize), 
     y = -pca.means$pc.scores[, 1],
     xlim = c(4.7, 6.1),
     col = col.means, 
     pch = pch.evo.allo, 
     xlab = "Log Centroid size", 
     ylab = "PC1 score", 
     main = "Evolutionary Allometry: PC1 vs Log Centroid Size")
text(5.6, 0, paste("r =", cor.1), col = "dark grey")
legend(6, 0.130, legend = names.phylo, col = col.phylo, pch = 16, cex = 0.60)
```

### ProcD Allometry visualization
```{r}
evo.procD <- geomorph.data.frame(shape = mean.shapes, size = info.means$MeanCsize, genus = info.means$Genus)
mean.allo <- procD.allometry(shape ~ log(size), data = evo.procD)

cor.allo <- cor.test(log(info.means$MeanCsize), mean.allo$CAC, method = "pearson")
cor.allo.short <- round(cor.allo$estimate, 2)

# Plot predicted allometric shape
plot(x = log(info.means$MeanCsize),
     y = mean.allo$CAC,
     xlim = c(4.7, 6.13),
     col = col.means, 
     pch = 16,
     main = "Predicted Mean Allometric Shape",
     xlab = "Log centroid size", 
     ylab = "Common Allometric Component")
legend(6.02, 0.13, legend = names.phylo, col = col.phylo, pch = 16, cex = 0.6)
text(5.7, 0.02, paste("r = ", cor.allo.short), col = "dark grey")
```

## Prepare the tree data for phylogenetic analyses
The commands in `geomorph` require the tree and datasets to have exactly the same set of species.

### Load in phylogenetic tree
The most recent tree for Australian rodents is from Smissen & Rowe 2018, Figure 2. The tree is a fossil calibrated ultrametric tree from BEAST2 for Hydromini, which includes all the Australo-Papuan old endemics in Murinae.
```{r}
Rowe.tree <- "../Data/Processed/Smissen-Rowe-2018-concat.tre"  # 
raw.tree <- read.tree(Rowe.tree)
```

### Extract only Genus and Species names from the tree
The tree file has uneven amounts of information for each entry, some entries have catalog numbers and others do not. Therefore we needed a `for` loop to grab the first two elements from a list, which always corresponded to Genus and Species.

We reassign only Genus and Species names (in form "Genus_species") to the tree so that going forward it is easier to compare to the shape data. 
```{r}
no.cat.tree <- raw.tree  # initiate new, modified tree with no CatNums
label.list <- strsplit(raw.tree$tip.label, "_")  # separate info into list

# For loop finds Genus & Species and reassigns tip name as "Genus_species"
for (i in 1:length(label.list)) {
        label <- unlist(label.list[i])
        no.cat.tree$tip.label[i] <- paste(label[1], label[2], sep = "_")
}
```

### Rename nodes
Since the 2018 Smissen & Rowe tree focused primarily on New Guinae species, it does not have all of the Australian species in our shape dataset. However, it does include sister species with the same relative branch length to other genera in the study. Therefore, we decided to rename some of the nodes with Australian species. 

**Renamed nodes:**
_Pogonomys macruourus_ (NG) to _Pogonomys mollipilosus_ (Aus)
_Melomys bannisteri_ (NG) to _Melomys burtoni_ (Aus)

```{r}
renamed.tree <- no.cat.tree
P.mac <- which(str_detect(no.cat.tree$tip.label, "Pogonomys_loriae"))
renamed.tree$tip.label[P.mac] <- paste("Pogonomys_mollipilosis")

# Optional plot
plot(renamed.tree)
tiplabels(cex = 0.1)
nodelabels(cex = 0.1)
axisPhylo()
```

### Prune the tree and shape datasets to match each other
Now that the names in the Smissen & Rowe tree can be compared to our info.phylo metadata, we can shape dataset to have all the same species.

First, prune the tree of species not in the shape data
```{r}
concord <- name.check(renamed.tree, renamed.tree$tip.label, dimnames(mean.shapes)[[3]])  # check concordance
aus.tree <- drop.tip(renamed.tree, concord$tree_not_data)  # prune tree to Aus
```

Second, remove duplicates of species in the tree
```{r}
dupes <- which(duplicated(aus.tree$tip.label))
aus.tree <- drop.tip(aus.tree, dupes)
```

Third, subset and re-order the metadata and shape datasets to match the order of species found in the tree. 
```{r}
# Subset
to.remove <- name.check(aus.tree, aus.tree$tip.label, dimnames(mean.shapes)[[3]])
info.means.tree <- info.means[!is.element(info.means$FullName, to.remove$data_not_tree), ]  # metadata
mean.shapes.tree <- mean.shapes[, , !is.element(info.means$FullName, to.remove$data_not_tree)]  # shape data

# Re-order to match tree tip order
tree.order <- match(aus.tree$tip.label, info.means.tree$FullName)
info.means.tree <- info.means.tree[tree.order, ]  # metadata
mean.shapes.tree <- mean.shapes.tree[, , tree.order]  # shape data
```

## Phylogenetic Analyses
First, test for phylogenetic signal in the shape data. 
```{r}
physignal(mean.shapes.tree, aus.tree, iter = 500)
```

### Evolutionary Allometry
```{r}
# Interaction with genus
evo.allo.gen.gdf <- geomorph.data.frame(shape = mean.shapes.tree, CS = info.means.tree$MeanCsize, genus = info.means.tree$Genus)
evo.allo.gen <- procD.pgls(shape ~log(CS) * genus, aus.tree, iter = 500, data = evo.allo.gen.gdf)
evo.allo.gen

# R squared for evolutionary allometry with genus
evo.allo.gen$R2
```

### Save intermediate data
```{r}
save(mean.shapes.tree, info.means.tree, aus.tree, file = "../Data/Processed/04-phylo-data.rda")
```